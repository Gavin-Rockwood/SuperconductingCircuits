import{_ as o,C as a,c as r,o as c,j as i,a as s,aA as l,G as n,w as p}from"./chunks/framework.W9DcKwru.js";const f=JSON.parse('{"title":"SuperconductingCircuits.jl Documentation","description":"","frontmatter":{},"headers":[],"relativePath":"index.md","filePath":"index.md","lastUpdated":1749334332000}'),d={name:"index.md"},u={class:"jldocstring custom-block",open:""};function h(m,t,g,k,y,C){const e=a("Badge");return c(),r("div",null,[t[4]||(t[4]=i("h1",{id:"SuperconductingCircuits.jl-Documentation",tabindex:"-1"},[s("SuperconductingCircuits.jl Documentation "),i("a",{class:"header-anchor",href:"#SuperconductingCircuits.jl-Documentation","aria-label":'Permalink to "SuperconductingCircuits.jl Documentation {#SuperconductingCircuits.jl-Documentation}"'},"â€‹")],-1)),i("details",u,[i("summary",null,[t[0]||(t[0]=i("a",{id:"SuperconductingCircuits.Circuits.init_circuit-Tuple{AbstractArray{SuperconductingCircuits.Circuits.Component}, Any}",href:"#SuperconductingCircuits.Circuits.init_circuit-Tuple{AbstractArray{SuperconductingCircuits.Circuits.Component}, Any}"},[i("span",{class:"jlbinding"},"SuperconductingCircuits.Circuits.init_circuit")],-1)),t[1]||(t[1]=s()),n(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),t[3]||(t[3]=l('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">init_circuit</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(components</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">AbstractArray{Component}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, interactions; operators_to_add</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Dict{String, Any}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(), use_sparse</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, dressed_kwargs</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Dict{Symbol, Any}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">())</span></span></code></pre></div><p>Initialize a quantum circuit from a list of components and their interactions.</p><p><strong>Arguments</strong></p><ul><li><p><code>components::AbstractArray{Component}</code>: An array of <code>Component</code> objects representing the subsystems of the circuit.</p></li><li><p><code>interactions</code>: A collection describing the interactions between components. Each interaction is typically a tuple or array where the first element is the coupling strength and the remaining elements specify the operators for each component.</p></li><li><p><code>operators_to_add=Dict{String, Any}()</code>: (Optional) A dictionary of additional operators to add to the circuit, keyed by operator name.</p></li><li><p><code>use_sparse=true</code>: (Optional) If <code>true</code>, use sparse matrix representations for operators and Hamiltonians.</p></li><li><p><code>dressed_kwargs=Dict{Symbol, Any}()</code>: (Optional) Keyword arguments passed to the dressed state calculation, such as <code>:f</code> (function for transformation) and <code>:step_number</code> (number of steps).</p></li></ul><p><strong>Returns</strong></p><ul><li><code>circuit::Circuit</code>: An initialized <code>Circuit</code> object containing the Hamiltonian, dressed states and energies, loss operators, component dictionary, and other relevant circuit information.</li></ul><p><strong>Details</strong></p><ul><li><p>Constructs the total Hilbert space dimensions and identity operators for each component.</p></li><li><p>Builds the bare Hamiltonian (<code>H_op_0</code>) and adds interaction terms to form the full Hamiltonian (<code>H_op</code>).</p></li><li><p>Calculates dressed states and energies using <code>get_dressed_states</code>.</p></li><li><p>Assembles loss operators for each component.</p></li><li><p>Organizes components and other circuit data into a <code>Circuit</code> struct.</p></li><li><p>Optionally adds user-specified operators to the circuit.</p></li></ul>',8)),n(e,{type:"info",class:"source-link",text:"source"},{default:p(()=>t[2]||(t[2]=[i("a",{href:" ",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1,__:[2]})])])}const b=o(d,[["render",h]]);export{f as __pageData,b as default};
